Цялостно за задачата използвам структура instruct, която репрезентира инструкциите и има размер 25 байта - както е по условие.
В началото на програмата правя стандарните проверки - колко са аргументите, дали програмата подадена като единствен аргумент се отваря коректно за четене.
Проверявам дали започва с ORC, както е по-условие, след което прочитам ram_size и заделям необходимата памет за опериране на програмата.
Всичко е придружено с проверки за кореткна работа на командите и коректност спрямо условието.
След това започва дълъг while цикъл, в който прочитам всички инструкции и в зависимост от техния opcode чрез switch-case извършвам описаната по условие функция на инструцията.
Преди всяко изпълняване на провечената инструкция има проверки за коректни аргументи и коректна работа на командите, които използвам.
Интерес представлява инструкцията 0x91, която прави скок. Реализирам я с lseek като слагам курсура на позиция 7+25*(стойността на клетката с адрес подадения аргумент) байта. 7 са байтовете, с които започва програмата (ORC и ram_size), а 25 байта е дължината/големината на всяка инструкция и така пресмятам къде трябва да застане курсура.
Аналогична е логиката и за инструкция 0x25, която пропуска следващата инструкция. Там отмествам курсора с 25 байта от настоящата му позиция.
За инструкция 0xbf, която представлява заспиване на програмата за подаден брой милисекунди, използвах информация и от интернет: https://stackoverflow.com/questions/1053788/implicit-declaration-of-function-usleep
Накрая преди дефолтния случай, има случай за прочетен 0x0a байт, който е краят на програмата и затова не се случва нищо.
Последен е дефолтния случай, който хваща невалидна инструкция.
Програмата приклюва с освобождаване на заделената оперативна памет и затваряне на файл дескриптора.
